#version 430

layout(local_size_x = 16, local_size_y = 16) in;

#if GL_NV_shader_atomic_fp16_vector
#define voxelLayout rgba16f
#else
#define voxelLayout rgba8
#endif

layout(binding = 0, voxelLayout) uniform readonly image3D voxelColor;
layout(binding = 1, voxelLayout) uniform readonly image3D voxelNormal;
layout(binding = 2, rgba8) uniform image3D voxelRadiance;

uniform sampler2D shadowmap;

uniform mat4 lsInverse;

uniform vec3 lightPos;
uniform vec3 lightInt;

uniform int voxelDim;
uniform vec3 voxelMin, voxelMax;
uniform vec3 voxelCenter;
uniform bool voxelWarp;

uniform bool radianceDilate = false;

#pragma include "common.glsl"

void main() {
    ivec2 threadId = ivec2(gl_GlobalInvocationID.xy);
    ivec2 shadowmapSize = textureSize(shadowmap, 0);

    if (threadId.x > shadowmapSize.x || threadId.y > shadowmapSize.y)
        return;

    // Unproject from shadowmap and get associated voxel position
    vec2 shadowmapTexcoord = vec2(threadId) / vec2(shadowmapSize);
    float shadowmapDepth = texture(shadowmap, shadowmapTexcoord).r;
    vec3 ndc = vec3(shadowmapTexcoord, shadowmapDepth) * 2 - vec3(1);
    vec3 worldPosition = (lsInverse * vec4(ndc, 1)).xyz;
    ivec3 voxelPosition = ivec3(voxelIndex(worldPosition, voxelDim, voxelCenter, voxelMin, voxelMax, voxelWarp));

    if (any(greaterThanEqual(voxelPosition, ivec3(voxelDim))) || any(lessThan(voxelPosition, ivec3(0)))) {
        return;
    }

    if (radianceDilate) {
        const ivec3 offsets[] = ivec3[](
            ivec3(0, 0, 0),
            ivec3(0, 0, 1), ivec3(-1, 0, 0),
            ivec3(0, 1, 0), ivec3(0, -1, 0),
            ivec3(1, 0, 0), ivec3(-1, 0, 0)
        );

        for (int i = 0; i < 7; i++) {
            ivec3 voxelIndex = voxelPosition + offsets[i];
            
            vec4 color = imageLoad(voxelColor, voxelIndex);
            imageStore(voxelRadiance, voxelIndex, color);
        }
    }
    else {
        // Calculate diffuse lighting
        vec4 color = imageLoad(voxelColor, voxelPosition);
        vec3 normal = normalize(imageLoad(voxelNormal, voxelPosition).xyz);

        vec3 lightVector = normalize(lightPos - worldPosition);
        float diffuse = max(dot(normal, lightVector), 0);

        // TODO
        // color.rgb = diffuse * lightInt * color.rgb;

        // Inject into voxel texture
        // imageStore(voxelColor, voxelPosition, f16vec4(color));
        vec4 previousColor = imageLoad(voxelRadiance, voxelPosition);
        if (previousColor.a > 0.1)
            color.rgb = mix(color.rgb, previousColor.rgb / previousColor.a, previousColor.a);
        imageStore(voxelRadiance, voxelPosition, color);
    }
}